{% extends 'base.html' %}

{% block title %}Computer science - {% endblock %}

{% block content %}
<style>
  .first {
    font-size: 30px;
    margin: 30px 0 15px;
    color: #333333;
  }

  .second {
    font-size: 20px;
    margin: 20px 0 10px;
    text-decoration: underline;
    color: #333333;
  }

  .third {
    font-size: 100%;
    color: #333333;
    font-weight: 600;
  }

  .size {
    font-size: 130%;
  }

  p,
  button {
    font-size: 100%;
  }

  #integer1_remove {
    display: none;
  }

  iframe {
    display: block;
    margin: 0 auto;
  }

  .sidebar {
    position: fixed;
    margin-left: -375px;
    border-left: 8px solid #c8dce3;
    background-color: #fff;
    overflow-y: scroll;
  }

  .sidebar {
    width: 350px;
    height: 85vh;
  }

  .core {
    padding: 7px;
    width: 100%;
    background-color: beige;
    font-size: larger;
    margin-top: 15px;
    margin-bottom: 10px;
  }

  .core:first-child {
    margin-top: 0px;
  }

  .topic {
    padding-left: 15px;
  }

  .topic a {
    color: #333333;
  }

  .topic a:hover {
    text-decoration: underline;
  }

  a.anchor {
    display: block;
    position: relative;
    top: -150px;
    visibility: hidden;
  }

  .sidebar::-webkit-scrollbar {
    width: 8px;
    /* width of the entire scrollbar */
  }

  .sidebar::-webkit-scrollbar-track {
    background: beige;
    /* color of the tracking area */
  }

  .sidebar::-webkit-scrollbar-thumb {
    background-color: #c8dce3;
    /* color of the scroll thumb */
    /* roundness of the scroll thumb */
    border: 3px solid #c8dce3;
    /* creates padding around scroll thumb */
  }
</style>

<div class="sidebar">
  <div class="core">Software developmental fundamentals</div>
  <div class="topic"><a href="#algorithm_design">Algorithms and design</a></div>
  <div class="topic"><a href="#fundamental_programming">Fundamental programming concepts</a></div>
  <div class="topic"><a href="#fundamental_data">Fundamental data structures</a></div>
  <div class="topic"><a href="#development_methods">Development methods</a></div>
  <div class="core">Discrete structures</div>
  <div class="topic"><a href="#sets">Sets, relations, and functions</a></div>
  <div class="topic"><a href="#sets">Basic logic</a></div>
  <div class="topic"><a href="#sets">Proof techniques</a></div>
  <div class="topic"><a href="#sets">Basics of counting</a></div>
  <div class="topic"><a href="#sets">Graphs and trees</a></div>
  <div class="topic"><a href="#sets">Discrete probability</a></div>
  <div class="core">Algorithms and complexity</div>
  <div class="topic"><a href="#sets">Basic analysis</a></div>
  <div class="topic"><a href="#sets">Algorithmic strategies</a></div>
  <div class="topic"><a href="#sets">Fundamental data structures and algorithms</a></div>
  <div class="topic"><a href="#sets">Basic automata, computability and complexity</a></div>
  <div class="topic"><a href="#sets">Advanced computational complexity</a></div>
  <div class="topic"><a href="#sets">Advanced automata theory and computability</a></div>
  <div class="topic"><a href="#sets">Advanced data structures, algorithms, and analysis</a></div>
  <div class="core">Software engineering</div>
  <div class="topic"><a href="#software_requirements">Software requirements</a></div>
  <div class="topic"><a href="#software_design">Software design</a></div>
  <div class="topic"><a href="#software_construction">Software construction</a></div>
  <div class="topic"><a href="#software_testing">Software testing</a></div>
  <div class="topic"><a href="#software_maintenance">Software maintenance</a></div>
  <div class="topic"><a href="#software_configuration_management">Software configuration management</a></div>
  <div class="topic"><a href="#software_engineering management">Software engineering management</a></div>
  <div class="topic"><a href="#software engineering process">Software engnieering process</a></div>
  <div class="topic"><a href="#software_engineering_models_and_methods">Software engineering models and methods</a>
  </div>
  <div class="topic"><a href="#software_quality">Software quality</a></div>
  <div class="topic"><a href="#software_engineering_professional_practie">Software engineering professional practice</a>
  </div>
  <div class="topic"><a href="#software_engineering_economics">Software engineering economics</a></div>
  <div class="topic"><a href="#computing_foundations">Computing foundations</a></div>
  <div class="topic"><a href="#mathematical_foundations">Mathematical foundations</a></div>
  <div class="topic"><a href="#engineering_foundations">Engineering foundations</a></div>
  <div class="core">Systems fundamentals</div>
  <div class="topic"><a href="#sets">Computational paradigms</a></div>
  <div class="topic"><a href="#sets">Cross-layer communications</a></div>
  <div class="topic"><a href="#sets">State and state machines</a></div>
  <div class="topic"><a href="#sets">Parallelism</a></div>
  <div class="topic"><a href="#sets">Evaluation</a></div>
  <div class="topic"><a href="#sets">Resource allocation and scheduling</a></div>
  <div class="topic"><a href="#sets">Proximity</a></div>
  <div class="topic"><a href="#sets">Virtualization and isolation</a></div>
  <div class="topic"><a href="#sets">Reliability through redundancy</a></div>
  <div class="topic"><a href="#sets">Quantitative evaluation</a></div>
  <div class="core">Architecture and organization</div>
  <div class="topic"><a href="#sets">Digital logic and digital systems</a></div>
  <div class="topic"><a href="#sets">Machine level representation of data</a></div>
  <div class="topic"><a href="#sets">Assembly level machine organization</a></div>
  <div class="topic"><a href="#sets">Memory system organization and architecture</a></div>
  <div class="topic"><a href="#sets">Interfacing and communication</a></div>
  <div class="topic"><a href="#sets">Functional organization</a></div>
  <div class="topic"><a href="#sets">Multiprocessing and alternative architectures</a></div>
  <div class="topic"><a href="#sets">Performance enhancements</a></div>
  <div class="core">Computational science</div>
  <div class="topic"><a href="#sets">Introduction to modeling and simulation</a></div>
  <div class="topic"><a href="#sets">Modeling and simulation</a></div>
  <div class="topic"><a href="#sets">Processing</a></div>
  <div class="topic"><a href="#sets">Interactive visualization</a></div>
  <div class="topic"><a href="#sets">Data, information, and knowledge</a></div>
  <div class="topic"><a href="#sets">Numerical analysis</a></div>
  <div class="core">Graphics and visualization</div>
  <div class="topic"><a href="#sets">Fundamental concepts</a></div>
  <div class="topic"><a href="#sets">Basic rendering</a></div>
  <div class="topic"><a href="#sets">Geometric modeling</a></div>
  <div class="topic"><a href="#sets">Advanced rendering</a></div>
  <div class="topic"><a href="#sets">Computer animation</a></div>
  <div class="topic"><a href="#sets">Visualization</a></div>
  <div class="core">Human-computer interaction</div>
  <div class="topic"><a href="#sets">Foundations</a></div>
  <div class="topic"><a href="#sets">Designing interaction</a></div>
  <div class="topic"><a href="#sets">Programming interactive systems</a></div>
  <div class="topic"><a href="#sets">User-centered design & testing</a></div>
  <div class="topic"><a href="#sets">New interactive technologies</a></div>
  <div class="topic"><a href="#sets">Collaboration & communication</a></div>
  <div class="topic"><a href="#sets">Statistical methods for HCI</a></div>
  <div class="topic"><a href="#sets">Human factors & security</a></div>
  <div class="topic"><a href="#sets">Design-oriented HCI</a></div>
  <div class="topic"><a href="#sets">Mixed, augmented and virtual reality</a></div>
  <div class="core">Information assurance and security</div>
  <div class="topic"><a href="#sets">Foundational concepts in security</a></div>
  <div class="topic"><a href="#sets">Principles of secure design</a></div>
  <div class="topic"><a href="#sets">Defensive programming</a></div>
  <div class="topic"><a href="#sets">Threats and attacks</a></div>
  <div class="topic"><a href="#sets">Network security</a></div>
  <div class="topic"><a href="#sets">Cryptography</a></div>
  <div class="topic"><a href="#sets">Web security</a></div>
  <div class="topic"><a href="#sets">Platform security</a></div>
  <div class="topic"><a href="#sets">Security policy and governance</a></div>
  <div class="topic"><a href="#sets">Digital forensics</a></div>
  <div class="topic"><a href="#sets">Secure software engineering</a></div>
  <div class="core">Information management</div>
  <div class="topic"><a href="#sets">Information management concepts</a></div>
  <div class="topic"><a href="#sets">Database systems</a></div>
  <div class="topic"><a href="#sets">Data modeling</a></div>
  <div class="topic"><a href="#sets">Indexing</a></div>
  <div class="topic"><a href="#sets">Relational databases</a></div>
  <div class="topic"><a href="#sets">Query languages</a></div>
  <div class="topic"><a href="#sets">Transaction processing</a></div>
  <div class="topic"><a href="#sets">Distributed databases</a></div>
  <div class="topic"><a href="#sets">Physical database design</a></div>
  <div class="topic"><a href="#sets">Data mining</a></div>
  <div class="topic"><a href="#sets">Information storage and retrieval</a></div>
  <div class="topic"><a href="#sets">Multimedia systems</a></div>
  <div class="core">Intelligent systems</div>
  <div class="topic"><a href="#sets">Fundamental issues</a></div>
  <div class="topic"><a href="#sets">Basic search strategies</a></div>
  <div class="topic"><a href="#sets">Basic knowledge representation and reasoning</a></div>
  <div class="topic"><a href="#sets">Basic machine learning</a></div>
  <div class="topic"><a href="#sets">Advanced search</a></div>
  <div class="topic"><a href="#sets">Advanced representation and reasoning</a></div>
  <div class="topic"><a href="#sets">Reasoning under uncertainty</a></div>
  <div class="topic"><a href="#sets">Agents</a></div>
  <div class="topic"><a href="#sets">Natural language processing</a></div>
  <div class="topic"><a href="#sets">Advanced machine learning</a></div>
  <div class="topic"><a href="#sets">Robotics</a></div>
  <div class="topic"><a href="#sets">Perception and computer vision</a></div>
  <div class="core">Networking and communication</div>
  <div class="topic"><a href="#sets">Introduction</a></div>
  <div class="topic"><a href="#sets">Networked applications</a></div>
  <div class="topic"><a href="#sets">Reliable data delivery</a></div>
  <div class="topic"><a href="#sets">Routing and forwarding</a></div>
  <div class="topic"><a href="#sets">Local area networks</a></div>
  <div class="topic"><a href="#sets">Resource allocation</a></div>
  <div class="topic"><a href="#sets">Mobility</a></div>
  <div class="topic"><a href="#sets">Social networking</a></div>
  <div class="core">Operating systems</div>
  <div class="topic"><a href="#overview_operating">Overview of operating systems</a></div>
  <div class="topic"><a href="#sets">Operating system principles</a></div>
  <div class="topic"><a href="#sets">Concurrency</a></div>
  <div class="topic"><a href="#sets">Scheduling and dispatch</a></div>
  <div class="topic"><a href="#sets">Memory management</a></div>
  <div class="topic"><a href="#sets">Security and protection</a></div>
  <div class="topic"><a href="#sets">Virtual machines</a></div>
  <div class="topic"><a href="#sets">Device management</a></div>
  <div class="topic"><a href="#sets">File systems</a></div>
  <div class="topic"><a href="#sets">Real time and embedded systems</a></div>
  <div class="topic"><a href="#sets">Fault tolerance</a></div>
  <div class="topic"><a href="#sets">System performance evaluation</a></div>
  <div class="core">Platform-based development</div>
  <div class="topic"><a href="#sets">Introduction</a></div>
  <div class="topic"><a href="#sets">Web platforms</a></div>
  <div class="topic"><a href="#sets">Mobile platforms</a></div>
  <div class="topic"><a href="#sets">Industrial platforms</a></div>
  <div class="topic"><a href="#sets">Game platforms</a></div>
  <div class="core">Parallel and distributed computing</div>
  <div class="topic"><a href="#sets">Parallelism fundamentals</a></div>
  <div class="topic"><a href="#sets">Parallel decomposition</a></div>
  <div class="topic"><a href="#sets">Communciation and coordination</a></div>
  <div class="topic"><a href="#sets">Parallel algorithm, analysis, and programming</a></div>
  <div class="topic"><a href="#sets">Parallel architecture</a></div>
  <div class="topic"><a href="#sets">Parallel performance</a></div>
  <div class="topic"><a href="#sets">Distributed systems</a></div>
  <div class="topic"><a href="#sets">Cloud computing</a></div>
  <div class="topic"><a href="#sets">Formal models and semantics</a></div>
  <div class="core">Programming languages</div>
  <div class="topic"><a href="#sets">Object-oriented programming</a></div>
  <div class="topic"><a href="#sets">Functional programming</a></div>
  <div class="topic"><a href="#sets">Event-driven and reactive programming</a></div>
  <div class="topic"><a href="#sets">Basic type systems</a></div>
  <div class="topic"><a href="#sets">Program representation</a></div>
  <div class="topic"><a href="#sets">Language translation and execution</a></div>
  <div class="topic"><a href="#sets">Syntax analysis</a></div>
  <div class="topic"><a href="#sets">Compiler semantic analysis</a></div>
  <div class="topic"><a href="#sets">Code generation</a></div>
  <div class="topic"><a href="#sets">Runtime systems</a></div>
  <div class="topic"><a href="#sets">Static analysis</a></div>
  <div class="topic"><a href="#sets">Advanced programming constructs</a></div>
  <div class="topic"><a href="#sets">Concurrency and parallelism</a></div>
  <div class="topic"><a href="#sets">Type systems</a></div>
  <div class="topic"><a href="#sets">Formal semantics</a></div>
  <div class="topic"><a href="#sets">Language pragmatics</a></div>
  <div class="topic"><a href="#sets">Logic programming</a></div>
  <div class="core">Social issues and professional practice</div>
  <div class="topic"><a href="#sets">Social context</a></div>
  <div class="topic"><a href="#sets">Analytical tools</a></div>
  <div class="topic"><a href="#sets">Professional ethics</a></div>
  <div class="topic"><a href="#sets">Intellectual property</a></div>
  <div class="topic"><a href="#sets">Privacy and civil liberties</a></div>
  <div class="topic"><a href="#sets">Professional communication</a></div>
  <div class="topic"><a href="#sets">Sustainability</a></div>
  <div class="topic"><a href="#sets">History</a></div>
  <div class="topic"><a href="#sets">Economies of computing</a></div>
  <div class="topic"><a href="#sets">Security policies, laws and computer crimes</a></div>
</div>
SWEBOK v3
<div class="first">Software requirements</div><a class="anchor" id="software_requirements"></a>
<div class="second">Software requirements fundamentals</div>
<p>Software engineering is the application of a systematic, disciplined, quantifiable approach to the development,
  operation, and maintenance of software; that is, the application of engineering to software.</p>
<div class="third">Defintion of a software requirement</div>
<p>At its most basic, a software requirement is a property that must be exhibited by something in order to solve some
  problem in the real world. An essential property of all software requirements it that they be verifiable as an
  individual feature as a functional requirement or at the system level as a nonfunctional requirement. Requirements
  have other attributes, such as priority ratings to enable tradeoffs in face of finite resources and a status value to
  enable project progress to be monitored. Software projects are critically vulnerable when the requirements-related
  activities are poorly performed. Software
  requirements express the needs and constraints placed on a software product that contribute to the solution of some
  real-world problem. The term "requirements engineering" denotes the systematic handling of requirements.</p>
<p>The waterfall model is a breakdown of project activities into linear sequential phases, where each phase depends on
  the deliverables of the previous one. It tends to be among the less iterative and flexible approaches.</p>
<div class="third">Product and process requirements</div>
<p>A product requirement is a need or constraint on the software to be developed. A process requirement is essentially a
  constraint on the developt of the software.</p>
<div class="third">Functional and nonfunctional requirements</div>
<p>Functional requirements describe the functions that the software is to execute, also known as capabilities or
  features. A functional requirement can also be described as one for which a finite set of test steps can be written to
  validate its behavior. Nonfunctional requirements are ones that act to constrain the solution, also known as
  constraints or quality requirements. Examples of nonfunctional requirements are performance requirements,
  maintainability requirements, safety, reliability, security, interoperability, etc.</p>
<div class="third">Emergent properties</div>
<p>Emergent properties are requirements that cannot be addressed by a single component but that depend on how all the
  software components interoperate. Emergent properties are crucially dependent on system architecture.</p>
<div class="third">Quantifiable requirements</div>
<p>Software requirements should be stated as clearly and as unambiguously as possible, and, where appropriate,
  quantitatively. This is particularly important for nonfunctional requirements.</p>
<div class="third">System requirements and software requirements</div>
<p>A "system" means an interacting combination of elements to accomplish a defined objective, including hardware,
  software, firmware, people, information, techniques, facilities, services, and other support elements. System
  requirements are the requirements for the system as a whole. Software requirements are derived from system
  requirements. User requirements are the requirements of the system's customers or end users.</p>
<div class="second">Requirements process</div>
<div class="third">Process models</div>
<p>The requirements process is not a discrete front-end activity of the software life cycle, but rather a process
  initiated at the beginning of a project that continues to be refined throughout the life cycle. Software requirements
  are configuration items and are managed using the same software configuratoin management practices as other products
  of the softawre life cycle processes. Requirements need to be adapted to the organizations and project context.</p>
<div class="third">Process actors</div>
<p>The requirements process is fundamentally interdisciplinary, and the requirements specialist needs to mediate between
  the domain of the stakeholder and that of software engineering. THe stakeholders will vary across projects, but will
  always include users/operators and customers. Examples of software stakeholders include users (those who use the
  software), customers (those who have commissioned the software), market analysts (marketing people who establish what
  the market needs are and who act as proxy customers), regulators (regulatory authorities such as for applications in
  banking and public transport), and software engineers (constraints can have major impact on project cost or delivery
  if they fit poorly with the skillset of the engineers). It is the job of the softawre engineer to negotiate tradeoffs
  acceptable to principal stakeholders within budgetary, technical, regulatory, and other constraints. A prerequisite
  for this is that all the stakeholders be identified, the nature of their "stake" analyzed, and their requirements
  elicited.</p>
<div class="third">Process support and management</div>
<div class="third">Process quality and improvement</div>
<div class="second">Requirements elictation</div>
<p>Requirements elictation, or requirements capture, or requirements discovery, or requirements acquisition is concerned
  with the origins of software requirements and how the software engineer can
  collect them. One of the fundamental principles of a good requirements elictation process is that of effective
  communication between various stakeholders, continuing through the entire Software Development Life Cycle (SDLC)
  process with different stakeholders at different points in time. A critical element of requirements elictation is
  informing the project scope, which involves providing a description of the software being specified and its purpose
  and prioritizing the deliverables to ensure the customer's most important business needs are satisfied first.</p>
<div class="third">Requirements sources</div>
<p>Goals: the term goal or business concern or critical success factor refers to the overall, high-level objectives of
  the software. Goals provide the motivation for the software but are often vaguely formulated. A feasibility study is a
  relatively low-cost way of assessing value and cost of goals.</p>
<p>Domain knowledge: the software engineer needs to acquire or have available knowledge about the application domain.
  Domain knowledge provides the background against which all elicited requirements knowledge must be set in ordre to
  understand it.</p>
<p>Stakeholders: the software engineer needs to identify, represent, and manage the "viewpoints" of many different types
  of stakeholders.</p>
<p>Business rules: there are statements that define or constrain some aspect of the structure or the behavior of the
  business itself.</p>
<p>The operational environment: requirements will be derived fro mthe environment in which the software will be executed
  (eg. real-time software or performance constraints in a business environment).</p>
<p>The organizational environment: software is often required to support a business process. In general, new software
  should not force unplanned change on the business process.</p>
<div class="third">Elictation techniques</div>
<p>Software engineer must be sensitized to the fact that users may have difficulty describing their tasks, may leave
  important information unstated, or may be unwilling or unable to cooperate. Elicitation is not a passive activity. A
  number of techniques exist:</p>
<p>Inteviews: interviewing stakeholders is a traditional means of eliciting requirements.</p>
<p>Scenarios: scenarios provide context. The most common type of secnario is the use case description.</p>
<p>Prototypes: helps clarify ambiguous requirements. Act similar to scenarios. There is a wide range of prototyping
  techniques, from paper mockups of screen designs to beta-test versions of software products. Low fidelity prototypes
  are often preferred to avoid stakeholder "anchoring" on minor, incidental characteristics of a higher quality
  prorotype.</p>
<p>Facilitated meetings: acheive a summative effect, whereby a group of people can bring more insight into their
  software requirements than by working individually. Allow conflicting requirements surface early.</p>
<p>Observation: observational techniques such as ethnography (study of cultures) can be expensive but also instructive.
</p>
<p>User stories: commonly used in adaptive methods and refers to short, high-level descriptions of required
  functionality expressed in customer terms.</p>
<div class="second">Requirements analysis</div>
<div class="third">Requirements classification</div>
<p>Is the requirement function or nonfunctional? Is the requirement derived from one or more high-level requirements or
  an emergent property, or is being imposed directly on the software by a stakeholder or some other source? Is the
  requirement on the product or the process? What's the priority of the requirement? What's the scope of the requirement
  (extent to which a requirmeent affects the software and its components)? What's the volatility/stability of the
  requirement?</p>
<div class="third">Conceptual modeling</div>
<p>Models aid in understanding the situation in which the problem occurs, as well as helps depict a solution. Many
  modeling notations are part of the United Modeling Language (UML). The factors that influence the choice of modeling
  notation includes 1) the nature of the problem, 2) the expertise of the softawre engineer, 3) the process
  requirements.</p>
<div class="third">Architectural design and requirements allocation</div>
<p>Architectural design is the point at which the requirements process overlaps with software or systems design.</p>
<div class="third">Requirements negotation</div>
<p>Another term commonly used for this is conflict resolution. In most cases it is unwise for the software engineer to
  make a unilateral decision. It is often important for contractual reasons that such decisions be traeable back to the
  customer. Requirements prioritization is necessary, not only as a means to filter important requirements, but also in
  order to resolve conflicts and plan for staged deliveries, which means making complex decisions that require detailed
  domain knowledge and good estimation skills. In practice, software engineers perform requirement prioritization
  frequently without knowing about all the requirements.</p>
<div class="third">Formal analysis</div>
<p>Formal analysis has made an impact on some application domains, especially high-integrity systems. The formal
  expression of requirements requires a language with formally defined semantics. Formal analysis allows requirements to
  be expressed precisely and unambiguously, and allow them to be reasoned over, permitting desired properties of the
  specified software to be proven. Formal reasoning requires tool support, which fall into theorem provers or model
  checkers. In neither case can proof be full yautomated, and the level of competence in formal reasoning in order to
  use the tools restricts the wider application of formal analysis. It is generally counterproductive to apply
  formalization until the business goals and user requirements have come into sharp focus. Once the requirements have
  been stabilized and have been elaborated to specify concrete properties of the software, it may be beneficial to
  formalize at least the critical requirements.</p>
<div class="second">Requirements specification</div>
<p>The term specification refers to the assignment of numerical values or limits to a product's design goals. In
  software engineering, this typically refers to the production of a document that can be systematically reviewed,
  evaluated, and approved. For complex systems, this may include system definition, system requirements, and software
  requirements.</p>
<div class="third">System definition document</div>
<p>Also known as the user requirements document or concept of operations document, the system definition document
  records the system requirements. It defines the high-level system requirements from the domain perspective. Its
  readership includes representatives of the system users/customers (eg. marketing for market-driven software). The
  document lists the system requirements along with background information about the overall objectives for the system,
  its target environment, and a statement of the constraints, assumptions, and nonfunctional requirements. It may
  include conceptual models designed to illustrate the system context, usage scenarios, and the principal domain
  entities, as well as workflows.</p>
<div class="third">System requirements specification</div>
<p>System requirements specification is a systems engineering activity and falls outside the scope of software
  engineering.</p>
<div class="third">Software requirements specification</div>
<p>Software requirements specification establishes the basis for agreement between customers and contractors or
  suppliers on what the software product is to do as well as what it is not expected to do. Software requirements
  specification permits a rigorous assessment of requirements before design can begin and reduces later redesign. It
  also provides a realistic basis for estimating product costs, risks, and schedules. Software requirements are often
  written in natural language, but may be supplemented by formal or semiformal descriptions. The general rule is that
  notations should be used that allow the requirements to be described as precisely as possible.</p>
<p>Quality indicators for individual software requirements specification statements include imperatives, directives,
  weak phrases, options, and continuances. Indicators for the entire software requirements specification document
  include size, readability, specification, depth, and text structure.</p>
<div class="second">Requirements validation</div>
<p>The requirements documents may be subject to validation and vertification procedures. This ensures that the software
  engineer has understood the requirements and veritifes that a requirements document conforms to company standards and
  that it is understandable, consistent, and complete.</p>
<p>Formal notations offer the important advantage of these properties to be proven (in a restricted sense, at least).
  Different stakeholders should review the documents. Requirements documents are subject to the same configuration
  management practices as the other dleiverables of the software life cycle processes. Requirements validation is
  concerned with the process of examining the requirements document to ensure that it defines the right software.</p>
<div class="third">Requirements reviews</div>
<p>Perhaps the most common means of validation is by inspection or reviews of the requirements documents. A group of
  reviewers is assigned a brief to look for errors, mistaken assumptions, lack of clarity, and deviation from standard
  practice.</p>
<div class="third">Prototyping</div>
<p>Prototyping is commonly a means for validating the software engineer's interpretation of the software requirements,
  as well as for eliciting new requirements. The advantage of prototypes is they can make it easier to interpret the
  software engineer's assumptions and give useful feedback on why they are wrong. Disadvantages to prototyping include
  distraction of users' attention from core underlying functionaly towards quality or cosmetic problems. For this
  reason, some advocate prototypes that avoid software, such as flip-chart-based mockups. Prototypes may be costly to
  develop, but can avoid the wastage of resources caused by trying to satisfy erroneous requirements.</p>
<div class="third">Model validation</div>
<p>It is typically necessary to validate the quality of the models developed during analysis.</p>
<div class="third">Acceptance tests</div>
<p>An essential property of a software requirement is that it should be possible to validate that the finished product
  satisfies it. Requirements that cannot be validated are really just "wishes." An important task is therefore planning
  how to verify each requirement. In most cases, designing acceptance tests does this for how end-users typically
  conduct business using the system. Identifying and designing acceptance tests may be difficult for nonfunctional
  requirements. To be validated, they must first be analyzed and decomposed to the point where they can be expressed
  quantitatively.</p>
<div class="second">Practical considerations</div>
<p>The requirements process spans the whole software life cycle. Change management and the maintenance of the
  requirements in a state that accurately mirrors the software to be built, or that has been built, are key to the
  success of the software engineering process. Not every organization has a culture of documenting and managing
  requirements (common in dynamic start-up companies). Most often, however, as these companies expand, as their customer
  base grows, they discover they need to recover the requirements that motivated product features in order to assess the
  impact of proposed changes. Requirements documentation and change management are key.</p>
<div class="third">Iterative nature of the requirements process</div>
<p>There is general pressure in the softare industry for ever shorter development cycles, which is particularly
  pronounced in highly competitive, market-driven sectors. Most projects are constrained in some way by their
  environment, and many are upgrades to, or revisions of, existing software where the architecture is given. In
  practice, therefore, it is almost always impractical to implement the requirements process as a linear, deterministic
  process in which software requirements are elicited from the stakeholders, baselined, allocated, and handed over to
  the software development team. It is certainly a myth that the requirements for large software projects are ever
  perfectly understood or perfectly specified.</p>
<p>For software products that develop iteratively, a project team may baseline only those requirements needed for the
  current iteration. The requirements specialist can continue to develop requirements for future iterations, while
  developers proceed with design and construction of the current iteration. This approach provides customers with
  business value quickly while minimizing the cost of rework. Perhaps the most crucial point in understanding software
  requirements is that a significant proportion of the requirements WILL change. This can be due to errors in the
  analysis or change in the environment, eg. customer's operating or business environment, regulatory processes imposed
  by authorities, or market into which software must sell. Change has to be managed by ensuring that proposed changes go
  thorugh a defined review and approval process and by applying careful requirements tracing, impact analysis, and
  software configuration management.</p>
<div class="third">Change management</div>
<div class="third">Requirements attributes</div>
<p>Requirements should consist not only of a specification of what is required, but also of ancillary information, which
  helps manage and interpret the requirements. Requirements attributes must be defined, recorded, and updated as the
  software under development or maintenance evolves. This should include the various classification dimensions of the
  requirement and the verification method or relevant acceptance test plan section It may also include additional
  information, such as a summary rationale for each requirement, the source of each requirement, and a change history.
  The most important requirements attribute is an identifier that allows the requirements to be uniquely and
  unambiguously identifeid.</p>
<div class="third">Requirements tracing</div>
<p>Requirements tracing is concerned with recovering the source of requirements and predicting the effects of
  requirements. Tracing is fundamental to performing impact analysis when requirements change. A requirement should be
  traceable backward to the reuqirements and stakeholders that motivated it. Conversely, a requirement should be
  traceable forward into the reuqirements and design entities that satisfy it (eg. on the code modules tha timplement it
  or the test cases related to that code or even the given section on the user manual which describes the actual
  functionality).</p>
<p>The requirements tracing for a typical project will form a complex directed acyclic graph (DAG). Maintaining an
  up-to-date graph or traceability matrix is an activity that must be considered during the whole life cycle of a
  product.</p>
<div class="third">Measuring requirements</div>
<p>Functionalize size measurement (FSM) is a technique for evaluating the size of a body of functional requirements.</p>
<div class="second">Software requirements tools</div>
<p>Tools for dealing with software requirements fall into tools for modeling and tools for managing requirements.
  Requirements management tools usually support documentation, tracing, and change management. Many organizations have
  invested in requirements management tools, although many more manage their requirements in more ad hoc and generally
  less satisfactory ways (eg. using spreadsheets).</p>
<div class="first">Software design</div><a class="anchor" id="software_design"></a>
<p>Design is defined as both "the process of defining the architecture, components, interfaces, and other
  characteristics of a system or component" and "the result of that process." Viewed as a process, software design is
  the software engineering life cycle activity in which software requirements are analyzed in order to produce a
  description of the software's internal structure that will serve as the basis for its construction. A software design
  describes the software architecture-that is, how the softawre is decomposed and organized into components-and the
  interfaces between those components. It also describes the components at a level of detail that enables their
  construction.</p>
<div class="second">Software design fundamentals</div>
<div class="third">General design concepts</div>
<p>Design can be viewed as a form of problem solving. The concept of a wicked problem-a problem with no definitive
  solution- is interesting in understanding the limits of design. Goals, constraints, alternatives, representations, and
  solutions are of interest in understanding design in its general sense.</p>
<div class="third">Context of software design</div>
<div class="third">Software design process</div>
<p>Software design is generally a two step process: architectural design (high-level or top-level design) that describes
  how software is organized into components, and detailed design that describes the desired behavior of these
  components. The output of these two processes is a set of models and artifacts that record the major decisions that
  have been taken, along with an explanation of the rationale for each nontrivial decision.</p>
<div class="third">Software design principles</div>
<p>A principle is a comprehensive and fundamental law, doctrine, or assumption. Software design principles include
  abstraction; coupling and cohesion; decomposition and modularization; encapsulation/information hiding; separation of
  interface and implementation; sufficiency, completeness, and primitiveness; and separation of concerns.</p>
<p>Abstraction is a view of an object that focuses on the information relevant to a particular purpose and ignores the
  remainder of the information. Two key abstraction mechanisms are parametrization and specification. Parametrization
  abstracts from the details of data representations by representing the data as named parameters. Abstraction by
  specification leads to procedural abstraction, data abstraction, and control (iteration) abstraction.</p>
<p>Coupling is defined as a measure of the interdependence among modules in a computer program and cohesion is the
  measure of the strength of association of the elements within a module.</p>
<p>Decomposing and modularizing means that large software is divided into a number of smaller named components having
  well-defined interfaces that describe component interactions. Usually the goal is to place different functionalities
  and responsibilities in different components.</p>
<p>Encapsulation and information hiding is grouping and packaging the internal details of an abstraction and making
  those details inaccessible to external entities.
</p>
<p>The separation of interface and implementation defines a component by specifying a public interface (known to
  clients) that is separate from the details of how the
  component is realized.</p>
<p>Sufficiency and completeness ensures that a software component captures all the important characteristics of an
  abstraction and nothing more.
  Primitiveness means the design should be based on patterns that are easy to implement.</p>
<p>A concern is an "area of interest with respect to a software design." A design concern is an area of design that is
  relevant to one or more of its stakeholders. Separating concerns by views allows stakeholders to focus on a few things
  at a time and offers a means of managing complexity.</p>
<div class="second">Key issues in software design</div>
<p>Key issues include performance, security, reliability, usability, and how to decompose, organize, and package
  software components. Non-key issues that deal with some aspect of software's behavior that is not in the application
  domain but which addresses some of the supporting domains, are sometimes referred to as aspects.</p>
<div class="third">Concurrency</div>
<p>Design for concurrency is concerned with decomposing software into processes, tasks, and threads and dealing with
  related issues of efficiency, atomicity, synchronization, and scheduling.</p>
<div class="third">Control and handling of events</div>
<p>This is concerned with how to organize data and control flow and how to handle reactive and temporal events through
  various mechanisms such as implicit invocation and call-backs.</p>
<div class="third">Data persistence</div>
<p>Handles long-lived data.</p>
<div class="third">Distribution of components</div>
<p>This design issue is concerned with how to distribute the software across the hardware, how the components
  communicate, and how middleware can be used to deal with heterogeneous software.</p>
<div class="third">Error and exception handling and fault tolerance</div>
<p>How to prevent, tolerate, and process errors and deal with exceptional conditions.</p>
<div class="third">Interaction and presentation</div>
<p>Concerned with how to structure and organize interactions with users as well as the presentation of information (eg.
  separation of presentation and business logic using Model-View-Controller approach). Note that this does not specify
  user interface details, which is the task of user interface design.</p>
<div class="third">Security</div>
<p>How to prevent unauthorized disclosure, creation, change, deletion, or denial of access to information and other
  resources. Also concerned with how to tolerate security-related attacks or violations by limiting damage, continuing
  service, speeding repair and recovery, and failing and recovering securely. Access control is a fundamental concept of
  security, and one should also ensure the proper use of cryptology.</p>
<div class="second">Software structure and architecture</div>
<p>A software architecture is "the set of structures needed to reason about the system, which comprise software
  elements, relations among them, and properties of both." These design concepts can be used to design families of
  programs (ie. product lines). These are attempts to describe and thus reuse, design knowledge.</p>
<div class="third">Architectural structures and viewpoints</div>
<p>A view represents a partial aspect of a software architecture athat shows specific properties of a software system.
  Views pertain to distinct issues associated with software design. For example, the logical view (satisfying the
  functional requirements) vs. the process view (concurrency issues) vs. the physical view (distribution issues) vs. the
  development view (how the design is broken down into implementation units with explicit representatio nof the
  dependencies among the units).</p>
<div class="third">Architectural styles</div>
<p>An architectural style is a specialization of element and relation types, together with a set of constraints on how
  they can be used, or a provision of the software's high-level organization. Examples are general structures,
  distributed systems, interactive systems, and adaptable systems.</p>
<div class="third">Design patterns</div>
<p>A pattern is a common solution to a common problem in a given context, and design patterns are used to describe
  details at a lower level than architectural styles. These lower level design patterns include creational patterns (eg.
  builder, factory, prototype, singleton), structural patterns (eg. adapter, bridge, composite, decorator, facade,
  fly-weight, proxy), and behavioral patterns (eg. interpreter, iterator, mediator, memento, observer, state, strategy,
  template, visitor).</p>
<div class="third">Architecture design decisions</div>
<p>Architectural deisgn is a creative process. It is useful to think of the architectural design process from a
  decision-making perspective than from an activity perspective.</p>
<div class="third">Families of programs and frameworks</div>
<p>Software product lines can identify commonalities among members and design reusable and customizable components to
  account for variability among family membersn. In object-oriented (OO) programming, a key related notion is that of a
  framework: a partially completed software system that can be extended by appropriately instantiating specific
  extensions, such as plug-ins.</p>
<div class="second">User interface design</div>
<div class="third">General user interface design principles</div>
<p>User interface design should ensure that interaction between the human and the machine provides for effective
  operation and control of the machine. The user interface should be designed to match the skills, experience, and
  expectations of its anticipated users. This includes learnability (easy to learn), user familiarity (should use terms
  and concepts drawn from the experiences of people who will use the software), consistency (comparable operations are
  activated in the same way), minimal surprise, recoverability (allow users to recover from errors), user guidance (give
  meaningful feedback when errors occur and provide context-related help), and user diversity (allow for diverse types
  of users, eg. blind, poor eyesight, deaf, colorblind, etc.).</p>
<div class="third">User interface design issues</div>
<p>How should the user interact with the software? How should information from the software be presented to the user?
</p>
<div class="third">The design of user interaction modalities</div>
<p>User interaction styles can be classified into the following primary styles: question-answer (user issues a question
  to the software, and the software returns the answer), direct manipulation (users interact with objects on the
  computer screen), menu selection (user selects a command from a menu list of commands), form fill-in (user fills in
  forms), command language (user issues a command and related parameters), and natural language (user issues a command
  in natural language which is parsed and translated into software commands).</p>
<div class="third">The deisgn of information presentation</div>
<p>Information presentation may be textual or graphical in nature. A good design keeps the information presentation
  separate from the information itself. The MVC approach is an efective way to keep information presentation separated
  from information being presented. Response time and feedback are also part of design of information presentation.
  Response time is generally measured from the point at which a user executes a certain control action until the
  software responds with a response. An indication of progress is desirable while the software is preparing the
  response. Feedback can be provided by restating the user's input while processing is being completed. Abstract
  visualizatoins can be used when large amounts of information are to be presented.</p>
<p>Designers can use color to enhance an interface: limit the number of colors used, use color change to show change of
  software status, use color-coding to support the user's task, use color-coding in a thoughtful and consistent way, use
  colors to facilitate access for people with color blindness/deficiency, don't depend on color alone to convey
  important information.</p>
<div class="third">User interface design process</div>
<p>The design process usually involves 1) user analysis (designer analyzes users' tasks and how users interact with
  other people, 2) software prototyping, and 3) interface evaluation.</p>
<div class="third">Localization and internationalization</div>
<p>User interface design often needs to consider internationalization and localization, which are means of adapting
  softawre to the different languages, regional differences, and the technical requirements of a target market.
  Internationalization is the process of designing a software application so that it can be adapted to various languages
  and regions without major engineering changes. Localization is the process of adapting internationalized software for
  a specific region or language by adding locale-specific components and translating the text. Localization and
  internationalization should consider factors such as symbols, numbers, currency, time, and measurement units.</p>
<div class="third">Metaphors and conceptual models</div>
<p>An example of a metaphor is an icon of a trash ca nas a metaphor for the operation delete. Metaphors present
  potential problems with respect to internationalization since not all metaphors are meaningful across cultures.</p>
<div class="second">Software design quality analysis and evaluation</div>
<div class="third">Quality attributes</div>
<p>There is a distinction between qualities discernable at runtmie (performance, security, availability, functionality,
  usability) and those that are not (modifiability, portability, reusability, testability), and those related to
  architecture's intrinsic qualities (eg. conceptual integrity, correctness, completeness).</p>
<div class="third">Quality analysis and evaluation techniques</div>
<p>Software design reviews are informal and formalized techniques to determine the quality of design artifacts. Static
  analysis are formal or semiformal static (nonexecutable) analysis that can be used to evaluate a design (eg.
  fault-tree analysis or automated cross-checking). Design vulnerability analysis can be performed if security is a
  concern. Formal design analysis uses mathematical models that allow designers to predicate the behavior and validate
  the performance of software instead of having to rely entirely on testing. Simulation and prototyping can help analyze
  quality.</p>
<div class="third">Measures</div>
<p>Measures can be classified as function-based (structured) which are obtained by analyzing functional decomposition,
  generally represented using a structure chart aka hierarchical diagram, and object-oriented design measures which are
  usually represented as a class diagram.</p>
<div class="second">Software design notations</div>
<div class="third">Structural descriptions (static view)</div>
<p>Mostly but not always graphical notations that describe and represent the structural aspects of a software
  design-that is, they are used to describe the major components and how they are interconnected: architecture
  description languages (ADLs) are textual, often formal, languages used to describe software architecture in terms of
  components and connectors, class and object diagrams are used to represent a set of classes and objects and their
  interrelationships, component diagrams represent a set of components (physical and replaceable parts of a system that
  conform to and provide the realization of a set of interfaces) and their interrelationships, class responsibility
  collaborator cards (CRCs) denote names, responsibilities, and collaborators of components, deployment diagrams
  represent a set of physical nodes and their relationships, entity-relationship diagrams (ERDs) represent conceptual
  models of data stored in information repositories, interface description languages (IDLs) are programming-like
  languages used to define interfaces of software components, and structure charts are used to describe the calling
  structure of programs.</p>
<div class="third">Behavioral descriptions (dynamic view)</div>
<p>Activity diagrams are used to show control flow from activity to activity. Communication diagrams show interactions
  that occur among a grou pof objects (emphasis on objects, their links, and the messages they exchange on those links).
  Data flow diagrams (DFDs) show data flow among elements and can be used for security analysis as they offer
  identification of possible paths for attack and disclosure of confidential information. Decision tables and diagrams
  represent complex combinations of conditions and ctions. Flowcharts represent the flow of control and the associated
  actions to be performed. Sequence diagrams show interactions among a group of objects, with emphasis on the time
  ordering of messages passed between objects. State transition and state chart diagrams show control flow from state to
  state and how the behavior of a component changes based on its current state in a state machine. Formal specification
  languages are textual languages that use basic notions from mathematics (eg. logic, set, sequence) to rigorously and
  abstractly define software component interfaces and behavior, often in terms of pre- and postconditions. Pseudo code
  and program design languages (PDLs) are structured programming-like languages used to describe the behavior of a
  procedure or method.</p>
<div class="second">Software design strategies and methods</div>
<div class="third">Genreal strategies</div>
<p>Divide-and-conquer and stepwise refinement strategies, top-down vs. bottom-up strategies, and strategies making use
  of heuristics, use of patterns and pattern languages, and use of an iterative and incremental approach.</p>
<div class="third">Function-oriented (structured) design</div>
<p>One of the classical methods of software design, where decomposition centers on identifying the major software
  functions and then elaborating and refining them in a hierarchical top-down manner.</p>
<div class="third">Object-oriented design</div>
<p>Noun = object; verb = method; adjective = attribute, where inheritance and polymorphism play a key role. This has
  evolved since to a field of component-based design, where metainformation can be defined and accessed.</p>
<div class="third">Data structure-centered design</div>
<p>Starts from data structures a program manipulates rather than from the function it performs. The software engineer
  first describes the input and output data structures and then develops the program's control structure based on these
  data structure diagrams.</p>
<div class="third">Component-based design (CBD)</div>
<p>A software component is an independent unit, having well-defined interfaces and dependencies that can be composed and
  deployed independently. Component-based design addresses issues related to providing, developing, and itnegrating such
  componnets in order to improve reuse. Components with a certain degree of trustworthiness should not depend on less
  trustworthy components.</p>
<div class="third">Other methods</div>
<p>Iterative and adaptive methods implement software increments and reduce emphasis on rigorous software requirement and
  design. Aspect-oriented design constructs software using aspects to implement the crosscutting concerns and extensions
  that are identified during the software requirement process. Service-oriented architecture builds distributed software
  using web services executed on distributed computers.</p>
<div class="second">Software design tools</div>
<p>Software design tools help translate requirements model into a design representation, provide support for
  representing functional components and their interfaces, implement heuristics refinement and partitioning, and provide
  guidleines for quality assessment.</p>

<div class="first">Software construction</div><a class="anchor" id="software_construction"></a>
<div class="second">Software construction fundamentals</div>
<div class="third">Minimizing complexity</div>
<div class="third">Anticipating change</div>
<div class="third">Constructing for verification</div>
<div class="third">Reuse</div>
<div class="third">Standards in construction</div>
<div class="second">Managing construction</div>
<div class="third">Construction in life cycle models</div>
<div class="third">Construction planning</div>
<div class="third">Construction measurement</div>
<div class="second">Practical considerations</div>
<div class="third">Construction design</div>
<div class="third">Construction languages</div>
<div class="third">Coding</div>
<div class="third">Construction testing</div>
<div class="third">Construction for reuse</div>
<div class="third">Construction quality</div>
<div class="third">Integration</div>
<div class="second">Construction technologies</div>
<div class="third">API design and use</div>
<div class="third">Object-oriented runtime issues</div>
<div class="third">Parameterization and generics</div>
<div class="third">Assertions, design by contract, and defensive programming</div>
<div class="third">Error handling, exception handling, and fault tolerance</div>
<div class="third">Executable models</div>
<div class="third">State-based and table-driven construction techniques</div>
<div class="third">Runtime configuration and internationalization</div>
<div class="third">Grammar-based input processing</div>
<div class="third">Concurrency primitives</div>
<div class="third">Middleware</div>
<div class="third">Construction methods for distributed software</div>
<div class="third">Constructive heterogeneous systems</div>
<div class="third">Performance analysis and tuning</div>
<div class="third">Platform standards</div>
<div class="third">Test-first programming</div>
<div class="second">Software construction tools</div>
<div class="third">Development environments</div>
<div class="third">GUI builders</div>
<div class="third">Unit testing tools</div>
<div class="third">Profiling, performance analysis, and slicing tools</div>


<div class="first">Overview of operating systems</div><a class="anchor" id="overview_operating"></a>
<h4>Kernel</h4>
<p>The kernel is a computer program at the core of a computer's operating system that generally has complete control
  over everything in the system. It is the portion of the operating system that is always resident in memory, and
  facilitates interactions between hardware and software components. It controls all hardware resources (e.g. I/O,
  memory, cryptography) via device drivers, arbitrates conflicts between processes concerning such resources, and
  optimizes the utilization of common resources e.g. CPU & cache usage, file systems, and network sockets. It is one
  of
  the first programs loaded on startup (after the bootloader). It connects the application software to the hardware of
  a
  computer.</p>
<h4>Operating system</h4>
<p>An operating system is system software that manages computer hardware, software resources, and provides common
  services for computer programs.</p>
<h4>Assembly language</h4>
<p>Assembly language, or assembler language, is any low-level programming language in which there is a very strong
  correspondence between the instructions in the language and the architecture's machine code instructions. It usually
  has
  one statement per machine instruction. Assembly code is converted into executable machine code by a utility program
  reffered to as an assembler. The term originally meant "a program that assembles another program consisting of
  several
  sections into a single program." The conversion process is referred to as assembly, as in assembling the source
  code.
</p>
<h4>Linux</h4>
<p>Linux is a family of free and open-source operating systems based on the Linux kernel, examples include Debian,
  Ubuntu, Fedora, CentOS, Gentoo, Arch Linux, and many others. 90% of all cloud infrastructure and 74% of the world's
  smartphones are powered by Linux. Linux-based operating systems depend heavily on working with the command line
  interface, while most personal computers rely on graphical interfaces. Linux filesystems also have a different
  structure than those found on Windows or MacOS.</p>
<h4>Terminal</h4>
<p>A terminal is an input and output environment that presents a text-only window running a shell. A shell is a
  program
  that exposes the computer's operating system to a user or program. In Linux systems, the shell presented in a
  terminal
  is a command line interpreter. A command line interface is a user interface which processes commands to a computer
  program and outputs the results.</p>

<div class="first">Introduction</div><a class="anchor" id="platform"></a>
<h4>Overview of platforms (e.g., Web, Mobile, Game, Industrial)</h4>
<h4>Programming via platform-specific APIs</h4>
<h4>Overview of Platform Languages (e.g., Objective C, HTML5)</h4>
<h4>Programming under platform constraints</h4>
<div class="first">Web platforms</div><a class="anchor" id="web"></a>
<h4>Web programming languages (e.g., HTML5, JavaScript, PHP, CSS)</h4>
<h4>Web platform constraints</h4>
<h4>Software as a Service (SaaS)</h4>
<h4>Web standards</h4>
Design and implement a simple web application
Describe the constraints that the web puts on developers
Compare and contrast web programming with general purpose programming
Describe the differences between Software-as-a-Service and traditional software products
Discuss how web standards impact software development
Review an existing web application against a current web standard
<div class="first">Mobile platforms</div><a class="anchor" id="mobile"></a>
<div class="first">Industrial platforms</div><a class="anchor" id="industrial"></a>
<div class="first">Game platforms</div><a class="anchor" id="game"></a>
<div class="first">Object-oriented programming</div><a class="anchor" id="platform"></a>
<h4>Object-oriented design</h4>
Decomposition into objects carrying state and having behavior, class-hierarchy design for modeling
<h4>Definition of classes: fields, methods, and constructors</h4>
<h4>Subclasses, inheritance, and method overriding</h4>
<h4>Dynamic dispatch: definition of method-call</h4>
<div class="first">Functional programming</div><a class="anchor" id="platform"></a>
<h4>Effect-free programming</h4>
Function calls have no side effects, facilitating compositional reasoning
Variables are immutable, preventing unexpected changes to program data by other code
Data can be freely aliased or copied without introducing unintended effects from mutation
<h4>Processing structured data (e.g., trees) via functions with cases for each data variant</h4>
Associated language constructs such as discriminated unions and pattern-matching over them
Functions defined over compound data in terms of functions applied to the constituent pieces
<h4>First-class functions (taking, returning, and storing functions)</h4>
<div class="first">Event-driven and reactive programming</div><a class="anchor" id="platform"></a>
<h4>Events and event handlers</h4>
<h4>Canonical uses such as GUIs, mobile devices, robots, servers</h4>
<h4>Using a reactive framework</h4>
Defining event handlers/listeners
Main event loop not under event-handler-writer's control
<h4>Externally-generated events and program-generated events</h4>
<h4>Separation of model, view, and controller</h4>
<div class="first">Basic type systems</div><a class="anchor" id="platform"></a>
<h4>A type as a set of values together with a set of operations</h4>
Primitive types (e.g., numbers, Booleans)
Compound types built from other types (e.g., records, unions, arrays, lists, functions, references)
<h4>Association of types to variables, arguments, results, and fields</h4>
<h4>Type safety and errors caused by using values inconsistently given their intended types</h4>
<h4>Goals and limitations of static typing</h4>
Eliminating some classes of errors without running the program
Undecidability means static analysis must conservatively approximate program behavior
<div class="first">Program representation</div><a class="anchor" id="platform"></a>
<div class="first">Language translation and execution</div><a class="anchor" id="platform"></a>
<div class="first">Syntax analysis</div><a class="anchor" id="platform"></a>
<div class="first">Compiler semantic analysis</div><a class="anchor" id="platform"></a>
<div class="first">Code generation</div><a class="anchor" id="platform"></a>
<div class="first">Runtime systems</div><a class="anchor" id="platform"></a>
<div class="first">Static analysis</div><a class="anchor" id="platform"></a>
<div class="first">Advanced programming constructs</div><a class="anchor" id="platform"></a>
<div class="first">Concurrency and parallelism</div><a class="anchor" id="platform"></a>
<div class="first">Type systems</div><a class="anchor" id="platform"></a>
<div class="first">Formal semantics</div><a class="anchor" id="platform"></a>
<div class="first">Language pragmatics</div><a class="anchor" id="platform"></a>
<div class="first">Logic programming</div><a class="anchor" id="platform"></a>
<div class="first">Algorithms and design</div><a class="anchor" id="algorithm_design"></a>
<h4>The concept and properties of algorithms</h4>
Informal comparison of alogirthm efficiency (e.g., operation counts)
<h4>The role of algorithms in the problem-solving process</h4>
<h4>Problem-solving strategies</h4>
Iterative and recursive mathematical functions
Iterative and recursive traversal of data structures
Divide-and-conquer strategies
<h4>Fundamental design concepts and principles</h4>
Abstraction, program decomposition, encapsulation and information binding, separation of behavior and implementation
<div class="first">Fundamental programming concepts</div><a class="anchor" id="fundamental_programming"></a>
<h4>Basic syntax and semantics of a higher-level language</h4>
<h4>Variables and primitive data types (e.g., numbers, characters, Booleans)</h4>
<h4>Expressions and assignments</h4>
<h4>Simple I/O including file I/O</h4>
<h4>Conditional and iterative control structures</h4>
<h4>Functions and parameter passing</h4>
<h4>The concept of recursion</h4>
<div class="first">Fundamental data structures</div><a class="anchor" id="fundamental_data"></a>
<h4>Arrays</h4>
<h4>Records/structs (heterogeneous aggregates)</h4>
<h4>Strings and string processing</h4>
<h4>Abstract data types and their implementation</h4>
Stacks, queues, priorty queues, sets, maps
<h4>References and aliasing</h4>
<h4>Linked lists</h4>
<h4>Strategies for choosing the appropriate data structure</h4>
<div class="first">Development methods</div><a class="anchor" id="development_methods"></a>
<h4>Program comprehension</h4>
<h4>Program correctness</h4>
Types of errors (syntax, logic, run-time), the concept of a specification, defensive programming (e.g., secure coding,
exception handling), code reviews, testing fundamentals and test-case generation, the role and the use of contracts,
including pre- and post-conditions, unit testing
<h4>Simple refactoring</h4>
<h4>Modern programming environments</h4>
Code search, programming using library components and their APIs
<h4>Debugging strategies</h4>
<h4>Documentation and program style</h4>
<div class="first">Software processes</div><a class="anchor" id="platform"></a>
<h4>Systems level considerations, i.e., the interaction of software with its intended environment (cross-reference
  IAS/Secure Software Engineering)</h4>
<h4>Introduction to software process models (e.g., waterfall, incremental, agile)</h4>
Activities within software lifecycles
<h4>Programming in the large vs. individual programming</h4>
<div class="first">Software project management</div><a class="anchor" id="platform"></a>
<h4>Team participation</h4>
Team processes including responsibilities for tasks, meeting structure, and work schedule
Roles and responsibilities in a software team
Team conflict resolution
Risks associated with virtual teams (communication, perception, structure)
<h4>Effort estimation (at the personal level)</h4>
<h4>Risk (cross reference IAS/Secure Software Engineering)</h4>
The role of risk in the lifecycle
Risk categories including security, safety, market, financial, technology, people, quality, structure and process
<div class="first">Tools and environments</div><a class="anchor" id="platform"></a>
<h4>Software configuration management and version control</h4>
<h4>Release management</h4>
<h4>Requirements analysis and design modeling tools</h4>
<h4>Testing tools including static and dynamic analysis tools</h4>
<h4>Programming environments that automate parts of program construction processes (e.g., automated builds)</h4>
Continuous integration
<h4>Tool integration concepts and mechanisms</h4>
<div class="first">Requirements engineering</div><a class="anchor" id="platform"></a>
<h4>Describing functional requirements using, for example, use cases or user stories</h4>
<h4>Properties of requirements including consistency, validity, completeness, and feasibility</h4>
<div class="first">Software design</div><a class="anchor" id="platform"></a>
<h4>System design principles</h4>
Levels of abstraction (architectural design and detailed design), separation of concerns, information hiding, coupling
and cohesion, re-use of standard structures
<h4>Design paradigms</h4>
Structured design (top-down functional decomposition), object-oriented analysis and design, event driven design,
component-level design, data-structured centered, aspect oriented, function oriented, service oriented
<h4>Structural and behavioral models of software designs</h4>
<h4>Design patterns</h4>
<div class="first">Software construction</div><a class="anchor" id="platform"></a>
<h4>Coding practices</h4>
techniques, idioms/patterns, mechanisms for building quality programs (cross-reference IAS/Defensive Programming;
SDF/Development Methods)
Defensive coding practices
Secure coding practices
Using exception handling mechanisms to make programs more robust, fault-tolerant
<h4>Coding standards</h4>
<h4>Integration strategies</h4>
<h4>Development context: "green field" vs. existing code base</h4>
Change impact analysis, change actualization
<div class="first">Software verification and validation</div><a class="anchor" id="platform"></a>
<h4>Verification and validation concepts</h4>
<h4>Inspections, reviews, audits</h4>
<h4>Testing types, including human computer interface, usability, reliability, security, conformance to specification
  (cross-reference IAS/Secure Software Engineering)</h4>
<h4>Testing fundamentals (cross-reference SDF/Development Methods)</h4>
Unit, integration, validation, and system testing
Test plan creation and test case generation
Black-box and white-box testing techniques
Regression testing and test automation
<h4>Defect tracking</h4>
<h4>Limitations of testing in particular domains, such as parallel or safety-critical systems</h4>
<div class="first">Software evolution</div><a class="anchor" id="platform"></a>
<div class="first">Software reliability</div><a class="anchor" id="platform"></a>
<div class="first">Formal methods</div><a class="anchor" id="platform"></a>

<div class="size">
  https://www.acm.org/binaries/content/assets/education/cs2013_web_final.pdf
  <p>The top core competencies from computer science for general application include software development
    fundamentals,
    discrete structures, algorithms and complexity, and systems fundamentals.</p>
  <h1>Computer Science</h1>
  <h2>Algorithms and Complexity (AL)</h2>
  <h3>Basic Analysis</h3>
  Differences among best, expected, and worst case behaviors of an algorithm
  • Asymptotic analysis of upper and expected complexity bounds
  • Big O notation: formal definition
  • Complexity classes, such as constant, logarithmic, linear, quadratic, and exponential
  • Empirical measurements of performance
  • Time and space trade-offs in algorithms
  <h3>Algorithmic Strategies</h3>
  <h3>Fundamental Data Structures and Algorithms</h3>
  Simple numerical algorithms, such as computing the average of a list of numbers, finding the min, max,
  and mode in a list, approximating the square root of a number, or finding the greatest common divisor
  • Sequential and binary search algorithms
  • Worst case quadratic sorting algorithms (selection, insertion)
  • Worst or average case O(N log N) sorting algorithms (quicksort, heapsort, mergesort)
  • Hash tables, including strategies for avoiding and resolving collisions
  • Binary search trees
  o Common operations on binary search trees such as select min, max, insert, delete, iterate over tree
  • Graphs and graph algorithms
  o Representations of graphs (e.g., adjacency list, adjacency matrix)
  o Depth- and breadth-first traversals
  Heaps
  • Graphs and graph algorithms
  o Shortest-path algorithms (Dijkstra’s and Floyd’s algorithms)
  o Minimum spanning tree (Prim’s and Kruskal’s algorithms)
  • Pattern matching and string/text algorithms (e.g., substring matching, regular expression matching, longest
  common subsequence algorithms)
  <h3>Basic Automata Computability and Complexity</h3>
  Finite-state machines
  • Regular expressions
  • The halting problem
  <h3>Advanced Computational Complexity</h3>
  <h3>Advanced Automata Theory and Computability</h3>
  <h3>Advanced Data Structures Algorithms and Analysis</h3>
  <h2>Architecture and Organization (AR)</h2>
  <h3>Digital Logic and Digital Systems</h3>
  <h3>Machine Level Representation of Data</h3>
  Bits, bytes, and words
  • Numeric data representation and number bases
  • Fixed- and floating-point systems
  • Signed and twos-complement representations
  • Representation of non-numeric data (character codes, graphical data)
  • Representation of records and arrays
  <h3>Assembly Level Machine Organization</h3>
  <h3>Memory System Organization and Architecture</h3>
  Storage systems and their technology
  • Memory hierarchy: importance of temporal and spatial locality
  • Main memory organization and operations
  • Latency, cycle time, bandwidth, and interleaving
  • Cache memories (address mapping, block size, replacement and store policy)
  • Multiprocessor cache consistency/Using the memory system for inter-core synchronization/atomic memory
  operations
  • Virtual memory (page table, TLB)
  • Fault handling and reliability
  • Error coding, data compression, and data integrity (cross-reference SF/Reliability through Redundancy)
  <h3>Interfacing and Communication</h3>
  <h3>Functional Organization</h3>
  <h3>Multiprocessing and Alternative Architectures</h3>
  <h3>Performance Enhancements</h3>
  <h2>Computational Science (CN)</h2>
  <p>Computational science is a field of applied computer science, that is, the application of computer science to
    solve
    problems across a range of disciplines. It combines computer simulation, scientific visualization, mathematical
    modeling, computer programming and data structures, networking, database design, symbolic computation, and high
    performance computing with various disciplines. The needs of scientists and engineers for computation have long
    driven research and innovation in computing. Computational neuroscience is a subfield of computational science.
  </p>
  <p>A goal in neural engineering is to abstract the concept of the brain. But the brain trying to model itself is a
    bit
    meta. Some say that dreams are essential models of various situations our subconscious is trying to prepare us
    for.
    In order to understand the brain, we should understand various modeling and simulation techniques used in
    computer
    science.</p>
  <h3>Introduction to Modeling and Simulation</h3>
  Models as abstractions of situations
  • Simulations as dynamic modeling
  • Simulation techniques and tools, such as physical simulations, human-in-the-loop guided simulations, and
  virtual reality
  • Foundational approaches to validating models (e.g., comparing a simulation’s output to real data or the
  output of another model)
  • Presentation of results in a form relevant to the system being modeled
  <h3>Modeling and Simulation</h3>
  Purpose of modeling and simulation including optimization; supporting decision making, forecasting,
  safety considerations; for training and education
  • Tradeoffs including performance, accuracy, validity, and complexity
  • The simulation process; identification of key characteristics or behaviors, simplifying assumptions;
  validation of outcomes
  • Model building: use of mathematical formulas or equations, graphs, constraints; methodologies and
  techniques; use of time stepping for dynamic systems
  Formal models and modeling techniques: mathematical descriptions involving simplifying assumptions
  and avoiding detail. Examples of techniques include:
  o Monte Carlo methods
  o Stochastic processes
  o Queuing theory
  o Petri nets and colored Petri nets
  o Graph structures such as directed graphs, trees, networks
  o Games, game theory, the modeling of things using game theory
  o Linear programming and its extensions
  o Dynamic programming
  o Differential equations: ODE, PDE
  o Non-linear techniques
  o State spaces and transitions
  • Assessing and evaluating models and simulations in a variety of contexts; verification and validation of
  models and simulations
  • Important application areas including health care and diagnostics, economics and finance, city and urban
  planning, science, and engineering
  • Software in support of simulation and modeling; packages, languages
  <h3>Processing</h3>
  <h3>Interactive Visualization</h3>
  <h3>Data, Information, and Knowledge</h3> !!
  Content management models, frameworks, systems, design methods (as in IM. Information Management)
  • Digital representations of content including numbers, text, images (e.g., raster and vector), video (e.g.,
  QuickTime, MPEG2, MPEG4), audio (e.g., written score, MIDI, sampled digitized sound track) and
  animations; complex/composite/aggregate objects; FRBR
  • Digital content creation/capture and preservation, including digitization, sampling, compression,
  conversion, transformation/translation, migration/emulation, crawling, harvesting
  • Content structure / management, including digital libraries and static/dynamic/stream aspects for:
  o Data: data structures, databases
  o Information: document collections, multimedia pools, hyperbases (hypertext, hypermedia),
  catalogs, repositories
  o Knowledge: ontologies, triple stores, semantic networks, rules
  • Processing and pattern recognition, including indexing, searching (including: queries and query languages;
  central / federated / P2P), retrieving, clustering, classifying/categorizing, analyzing/mining/extracting,
  rendering, reporting, handling transactions
  • User / society support for presentation and interaction, including browse, search, filter, route, visualize,
  share, collaborate, rate, annotate, personalize, recommend
  • Modeling, design, logical and physical implementation, using relevant systems/software
  <h3>Numerical Analysis</h3>
  <h2>Discrete Structures (DS)</h2>
  <h3>Sets, Relations, and Functions</h3>
  Sets
  o Venn diagrams
  o Union, intersection, complement
  o Cartesian product
  o Power sets
  o Cardinality of finite sets
  • Relations
  o Reflexivity, symmetry, transitivity
  o Equivalence relations, partial orders
  • Functions
  o Surjections, injections, bijections
  o Inverses
  o Composition
  <h3>Basic Logic</h3>
  Propositional logic (cross-reference: Propositional logic is also reviewed in IS/Knowledge Based
  Reasoning)
  • Logical connectives
  • Truth tables
  • Normal forms (conjunctive and disjunctive)
  • Validity of well-formed formula
  • Propositional inference rules (concepts of modus ponens and modus tollens)
  • Predicate logic
  o Universal and existential quantification
  • Limitations of propositional and predicate logic (e.g., expressiveness issues)
  <h3>Proof Techniques</h3>
  Notions of implication, equivalence, converse, inverse, contrapositive, negation, and contradiction
  • The structure of mathematical proofs
  • Direct proofs
  • Disproving by counterexample
  • Proof by contradiction
  • Induction over natural numbers
  <h4>Principle of Mathematical Induction</h4>
  <p>For each natural number \(n \in \mathbb{N}\), suppose that \(P(n)\) denotes a proposition which is either true
    or
    false. Let \(A={n \in \mathbb{N}:P(n)}\) is true. Suppose the following conditions hold: a) \(1 \in A\) and
    b) for each \(k \in \mathbb{N}\), if \(k \in A\)
    , then \(k+1 \in A\). Then \(A=\mathbb{N}\).</p>
  • Structural induction
  • Weak and strong induction (i.e., First and Second Principle of Induction)
  • Recursive mathematical definitions
  <h3>Basics of Counting</h3>
  Counting arguments
  o Set cardinality and counting
  o Sum and product rule
  o Inclusion-exclusion principle
  o Arithmetic and geometric progressions
  • The pigeonhole principle
  • Permutations and combinations
  o Basic definitions
  o Pascal’s identity
  o The binomial theorem
  • Solving recurrence relations (cross-reference: AL/Basic Analysis)
  o An example of a simple recurrence relation, such as Fibonacci numbers
  o Other examples, showing a variety of solutions
  • Basic modular arithmetic
  <h3>Graphs and Trees</h3>
  Trees
  o Properties
  o Traversal strategies
  • Undirected graphs
  • Directed graphs
  • Weighted graphs
  <h3>Discrete Probability</h3>
  Finite probability space, events
  • Axioms of probability and probability measures
  • Conditional probability, Bayes’ theorem
  • Independence
  • Integer random variables (Bernoulli, binomial)
  • Expectation, including Linearity of Expectation
  <h2>Graphics and Visualization (GV)</h2> !!
  Media applications including user interfaces, audio and video editing, game engines, cad, visualization,
  virtual reality
  • Digitization of analog data, resolution, and the limits of human perception, e.g., pixels for visual display,
  dots for laser printers, and samples for audio (HCI/Foundations)
  • Use of standard APIs for the construction of UIs and display of standard media formats (see HCI/GUI
  construction)
  • Standard media formats, including lossless and lossy formats
  <h3>Fundamental Concepts</h3>
  <h3>Basic Rendering</h3>
  <h3>Geometric Modeling</h3>
  <h3>Advanced Rendering</h3>
  <h3>Computer Animation</h3>
  <h3>Visualization</h3>
  Visualization of 2D/3D scalar fields: color mapping, isosurfaces
  • Direct volume data rendering: ray-casting, transfer functions, segmentation
  • Visualization of:
  o Vector fields and flow data
  o Time-varying data
  o High-dimensional data: dimension reduction, parallel coordinates,
  o Non-spatial data: multi-variate, tree/graph structured, text
  • Perceptual and cognitive foundations that drive visual abstractions
  • Visualization design
  • Evaluation of visualization methods
  • Applications of visualization
  <h2>Human-Computer Interaction (HCI)</h2>
  <h3>Foundations</h3>
  Contexts for HCI (anything with a user interface, e.g., webpage, business applications, mobile applications,
  and games)
  • Processes for user-centered development, e.g., early focus on users, empirical testing, iterative design
  • Different measures for evaluation, e.g., utility, efficiency, learnability, user satisfaction
  • Usability heuristics and the principles of usability testing
  • Physical capabilities that inform interaction design, e.g., color perception, ergonomics
  • Cognitive models that inform interaction design, e.g., attention, perception and recognition, movement, and
  memory; gulfs of expectation and execution
  • Social models that inform interaction design, e.g., culture, communication, networks and organizations
  • Principles of good design and good designers; engineering tradeoffs
  • Accessibility, e.g., interfaces for differently-abled populations (e.g., blind, motion-impaired)
  • Interfaces for differently-aged population groups (e.g., children, 80+)
  <h3>Designing Interaction</h3>
  Principles of graphical user interfaces (GUIs)
  • Elements of visual design (layout, color, fonts, labeling)
  • Task analysis, including qualitative aspects of generating task analytic models
  • Low-fidelity (paper) prototyping
  • Quantitative evaluation techniques, e.g., keystroke-level evaluation
  • Help and documentation
  • Handling human/system failure
  • User interface standards
  <h3>Programming Interactive Systems</h3>
  Software Architecture Patterns, e.g., Model-View controller; command objects, online, offline (cross
  reference PL/Event Driven and Reactive Programming, where MVC is used in the context of event-driven
  programming)
  • Interaction Design Patterns: visual hierarchy, navigational distance
  • Event management and user interaction
  • Geometry management (cross-reference GV/Geometric Modelling)
  • Choosing interaction styles and interaction techniques
  • Presenting information: navigation, representation, manipulation
  • Interface animation techniques (e.g., scene graphs)
  • Widget classes and libraries
  • Modern GUI libraries (e.g. iOS, Android, JavaFX) GUI builders and UI programming environments (crossreference
  PBD/Mobile Platforms)
  • Declarative Interface Specification: Stylesheets and DOMs
  • Data-driven applications (database-backed web pages)
  • Cross-platform design
  • Design for resource-constrained devices (e.g. small, mobile devices)
  <h3>User-Centered Design and Testing</h3>
  Approaches to, and characteristics of, the design process
  • Functionality and usability requirements (cross-reference to SE/Requirements Engineering)
  • Techniques for gathering requirements, e.g., interviews, surveys, ethnographic and contextual enquiry
  • Techniques and tools for the analysis and presentation of requirements, e.g., reports, personas
  • Prototyping techniques and tools, e.g., sketching, storyboards, low-fidelity prototyping, wireframes
  • Evaluation without users, using both qualitative and quantitative techniques, e.g., walkthroughs, GOMS,
  expert-based analysis, heuristics, guidelines, and standards
  • Evaluation with users, e.g., observation, think-aloud, interview, survey, experiment
  • Challenges to effective evaluation, e.g., sampling, generalization
  • Reporting the results of evaluations
  • Internationalization, designing for users from other cultures, cross-cultural
  <h3>New Interactive Technologies</h3>
  Choosing interaction styles and interaction techniques
  • Representing information to users: navigation, representation, manipulation
  • Approaches to design, implementation and evaluation of non-mouse interaction
  o Touch and multi-touch interfaces
  o Shared, embodied, and large interfaces
  o New input modalities (such as sensor and location data)
  o New Windows, e.g., iPhone, Android
  o Speech recognition and natural language processing (cross reference IS/Natural Language
  Processing)
  o Wearable and tangible interfaces
  o Persuasive interaction and emotion
  o Ubiquitous and context-aware interaction technologies (Ubicomp)
  o Bayesian inference (e.g. predictive text, guided pointing)
  o Ambient/peripheral display and interaction
  <h3>Collaboration and Communication</h3>
  <h3>Statistical Methods for HCI</h3>
  <h3>Human Factors and Security</h3>
  <h3>Design-Oriented HCI</h3>
  <h3>Mixed, Augmented and Virtual Reality</h3>
  Output
  o Sound
  o Stereoscopic display
  o Force feedback simulation, haptic devices
  • User input
  o Viewer and object tracking
  o Pose and gesture recognition
  o Accelerometers
  o Fiducial markers
  o User interface issues
  • Physical modelling and rendering
  o Physical simulation: collision detection & response, animation
  o Visibility computation
  o Time-critical rendering, multiple levels of details (LOD)
  • System architectures
  o Game engines
  o Mobile augmented reality
  o Flight simulators
  o CAVEs
  o Medical imaging
  • Networking
  o p2p, client-server, dead reckoning, encryption, synchronization
  o Distributed collaboration
  <h2>Information Assurance and Security (IAS)</h2>
  <h3>Foundational Concepts in Security</h3>
  <h3>Principles of Secure Design</h3>
  <h3>Defensive Programming</h3>
  <h3>Threats and Attacks</h3>
  <h3>Network Security</h3>
  <h3>Cryptography</h3>
  <h3>Web Security</h3>
  <h3>Platform Security</h3>
  <h3>Security Policy and Governance</h3>
  <h3>Digital Forensics</h3>
  <h3>Secure Software Engineering</h3>
  <h2>Information Management (IM)</h2>
  <h3>Information Management Concepts</h3>
  Information systems as socio-technical systems
  • Basic information storage and retrieval (IS&R) concepts
  • Information capture and representation
  • Supporting human needs: searching, retrieving, linking, browsing, navigating
  Approaches to and evolution of database systems
  • Components of database systems
  Design of core DBMS functions (e.g., query mechanisms, transaction management, buffer management,
  access methods)
  • Database architecture and data independence
  • Use of a declarative query language
  • Systems supporting structured and/or stream content
  <h3>Database Systems</h3>
  <h3>Data Modeling</h3>
  Data modeling
  • Conceptual models (e.g., entity-relationship, UML diagrams)
  • Spreadsheet models
  • Relational data models
  • Object-oriented models (cross-reference PL/Object-Oriented Programming)
  • Semi-structured data model (expressed using DTD or XML Schema, for example)
  <h3>Indexing</h3>
  The impact of indices on query performance
  • The basic structure of an index
  • Keeping a buffer of data in memory
  • Creating indexes with SQL
  • Indexing text
  • Indexing the web (e.g., web crawling)
  <h3>Relational Databases</h3>
  Mapping conceptual schema to a relational schema
  • Entity and referential integrity
  • Relational algebra and relational calculus
  • Relational Database design
  • Functional dependency
  • Decomposition of a schema; lossless-join and dependency-preservation properties of a decomposition
  • Candidate keys, superkeys, and closure of a set of attributes
  • Normal forms (BCNF)
  • Multi-valued dependency (4NF)
  • Join dependency (PJNF, 5NF)
  • Representation theory
  <h3>Query Languages</h3>
  Overview of database languages
  • SQL (data definition, query formulation, update sublanguage, constraints, integrity)
  • Selections
  • Projections
  • Select-project-join
  • Aggregates and group-by
  • Subqueries
  • QBE and 4th-generation environments
  • Different ways to invoke non-procedural queries in conventional languages
  • Introduction to other major query languages (e.g., XPATH, SPARQL)
  • Stored procedures
  <h3>Transaction Processing</h3>
  Transactions
  • Failure and recovery
  • Concurrency control
  • Interaction of transaction management with storage, especially buffering
  <h3>Distributed Databases</h3>
  <h3>Physical Database Design</h3>
  <h3>Data Mining</h3>
  Uses of data mining
  • Data mining algorithms
  • Associative and sequential patterns
  • Data clustering
  • Market basket analysis
  • Data cleaning
  • Data visualization (cross-reference GV/Visualization and CN/Interactive Visualization)
  <h3>Information Storage and Retrieval</h3>
  Documents, electronic publishing, markup, and markup languages
  • Tries, inverted files, PAT trees, signature files, indexing
  • Morphological analysis, stemming, phrases, stop lists
  • Term frequency distributions, uncertainty, fuzziness, weighting
  • Vector space, probabilistic, logical, and advanced models
  • Information needs, relevance, evaluation, effectiveness
  • Thesauri, ontologies, classification and categorization, metadata
  • Bibliographic information, bibliometrics, citations
  • Routing and (community) filtering
  • Multimedia search, information seeking behavior, user modeling, feedback
  • Information summarization and visualization
  • Faceted search (e.g., using citations, keywords, classification schemes)
  • Digital libraries
  • Digitization, storage, interchange, digital objects, composites, and packages
  • Metadata and cataloging
  • Naming, repositories, archives
  • Archiving and preservation, integrity
  • Spaces (conceptual, geographical, 2/3D, VR)
  • Architectures (agents, buses, wrappers/mediators), interoperability
  • Services (searching, linking, browsing, and so forth)
  • Intellectual property rights management, privacy, and protection (watermarking)
  <h3>Multimedia Systems</h3>
  • Input and output devices, device drivers, control signals and protocols, DSPs
  • Standards (e.g., audio, graphics, video)
  • Applications, media editors, authoring systems, and authoring
  • Streams/structures, capture/represent/transform, spaces/domains, compression/coding
  • Content-based analysis, indexing, and retrieval of audio, images, animation, and video
  Presentation, rendering, synchronization, multi-modal integration/interfaces
  • Real-time delivery, quality of service (including performance), capacity planning, audio/video
  conferencing, video-on-demand
  <h2>Intelligent Systems (IS)</h2>
  <h3>Fundamental Issues</h3>
  <h3>Basic Search Strategies</h3>
  <h3>Basic Knowledge Representation and Reasoning</h3>
  Review of propositional and predicate logic (cross-reference DS/Basic Logic)
  • Resolution and theorem proving (propositional logic only)
  • Forward chaining, backward chaining
  • Review of probabilistic reasoning, Bayes theorem (cross-reference with DS/Discrete Probability)
  <h3>Basic Machine Learning</h3>
  <h3>Advanced Search</h3>
  <h3>Advanced Representation and Reasoning</h3>
  <h3>Reasoning Under Uncertainty</h3>
  Review of basic probability (cross-reference DS/Discrete Probability)
  • Random variables and probability distributions
  o Axioms of probability
  o Probabilistic inference
  o Bayes’ Rule
  • Conditional Independence
  • Knowledge representations
  o Bayesian Networks
   Exact inference and its complexity
   Randomized sampling (Monte Carlo) methods (e.g. Gibbs sampling)
  o Markov Networks
  o Relational probability models
  o Hidden Markov Models
  • Decision Theory
  o Preferences and utility functions
  o Maximizing expected utility
  <h3>Agents</h3>
  Definitions of agents
  • Agent architectures (e.g., reactive, layered, cognitive)
  • Agent theory
  • Rationality, game theory
  o Decision-theoretic agents
  o Markov decision processes (MDP)
  • Software agents, personal assistants, and information access
  o Collaborative agents
  o Information-gathering agents
  o Believable agents (synthetic characters, modeling emotions in agents)
  • Learning agents
  • Multi-agent systems
  o Collaborating agents
  o Agent teams
  o Competitive agents (e.g., auctions, voting)
  o Swarm systems and biologically inspired models
  <h3>Natural Language Processing</h3>
  Deterministic and stochastic grammars
  • Parsing algorithms
  o CFGs and chart parsers (e.g. CYK)
  o Probabilistic CFGs and weighted CYK
  • Representing meaning / Semantics
  o Logic-based knowledge representations
  o Semantic roles
  o Temporal representations
  o Beliefs, desires, and intentions
  • Corpus-based methods
  • N-grams and HMMs
  • Smoothing and backoff
  Examples of use: POS tagging and morphology
  • Information retrieval (Cross-reference IM/Information Storage and Retrieval)
  o Vector space model
   TF & IDF
  o Precision and recall
  • Information extraction
  • Language translation
  • Text classification, categorization
  o Bag of words model
  <h3>Advanced Machine Learning</h3>
  Definition and examples of broad variety of machine learning tasks
  • General statistical-based learning, parameter estimation (maximum likelihood)
  • Inductive logic programming (ILP)
  • Supervised learning
  o Learning decision trees
  o Learning neural networks
  o Support vector machines (SVMs)
  • Ensembles
  • Nearest-neighbor algorithms
  • Unsupervised Learning and clustering
  o EM
  o K-means
  o Self-organizing maps
  • Semi-supervised learning
  • Learning graphical models (Cross-reference IS/Reasoning under Uncertainty)
  • Performance evaluation (such as cross-validation, area under ROC curve)
  • Learning theory
  • The problem of overfitting, the curse of dimensionality
  • Reinforcement learning
  o Exploration vs. exploitation trade-off
  o Markov decision processes
  o Value and policy iteration
  • Application of Machine Learning algorithms to Data Mining (cross-reference IM/Data Mining)
  <h3>Robotics</h3>
  Overview: problems and progress
  o State-of-the-art robot systems, including their sensors and an overview of their sensor processing
  o Robot control architectures, e.g., deliberative vs. reactive control and Braitenberg vehicles
  o World modeling and world models
  o Inherent uncertainty in sensing and in control
  • Configuration space and environmental maps
  • Interpreting uncertain sensor data
  • Localizing and mapping
  • Navigation and control
  • Motion planning
  • Multiple-robot coordination
  <h3>Perception and Computer Vision</h3>
  Computer vision
  o Image acquisition, representation, processing and properties
  o Shape representation, object recognition and segmentation
  o Motion analysis
  • Audio and speech recognition
  • Modularity in recognition
  • Approaches to pattern recognition (cross-reference IS/Advanced Machine Learning)
  o Classification algorithms and measures of classification quality
  o Statistical techniques
  <h2>Networking and Communication (NC)</h2>
  <h3>Introduction</h3>
  Organization of the Internet (Internet Service Providers, Content Providers, etc.)
  • Switching techniques (e.g., circuit, packet)
  • Physical pieces of a network, including hosts, routers, switches, ISPs, wireless, LAN, access point, and
  firewalls
  • Layering principles (encapsulation, multiplexing)
  • Roles of the different layers (application, transport, network, datalink, physical)
  <h3>Networked Applications</h3>
  Naming and address schemes (DNS, IP addresses, Uniform Resource Identifiers, etc.)
  • Distributed applications (client/server, peer-to-peer, cloud, etc.)
  • HTTP as an application layer protocol
  • Multiplexing with TCP and UDP
  • Socket APIs
  <h3>Reliable Data Delivery</h3>
  <h3>Routing and Forwarding</h3>
  <h3>Local Area Networks</h3>
  <h3>Resource Allocation</h3>
  <h3>Mobility</h3>
  <h3>Social Networking</h3>
  <h2>Operating Systems (OS)</h2>
  <h3>Overview of Operating Systems</h3>
  <h3>Operating System Principles</h3>
  <h3>Concurrency</h3>
  <h3>Scheduling and Dispatch</h3>
  <h3>Memory Management</h3>
  <h3>Security and Protection</h3>
  <h3>Virtual Machines</h3>
  <h3>Device Management</h3>
  <h3>File Systems</h3>
  <h3>Real Time and Embedded Systems</h3>
  <h3>Fault Tolerance</h3>
  <h3>System Performance Evaluation</h3>
  <h2>Platform-Based Development (PBD)</h2>
  <h3>Introduction</h3>
  <h3>Web Platforms</h3>
  <h3>Mobile Platforms</h3>
  <h3>Industrial Platforms</h3>
  <h3>Game Platforms</h3>
  <h2>Parallel and Distributed Computing (PD)</h2>
  <h3>Parallelism Fundamentals</h3>
  Multiple simultaneous computations
  • Goals of parallelism (e.g., throughput) versus concurrency (e.g., controlling access to shared resources)
  • Parallelism, communication, and coordination
  o Programming constructs for coordinating multiple simultaneous computations
  o Need for synchronization
  • Programming errors not found in sequential programming
  o Data races (simultaneous read/write or write/write of shared state)
  o Higher-level races (interleavings violating program intention, undesired non-determinism)
  o Lack of liveness/progress (deadlock, starvation)
  <h3>Parallel Decomposition</h3>
  <h3>Communication and Coordination</h3>
  <h3>Parallel Algorithms, Analysis, and Programming</h3>
  <h3>Parallel Architecture</h3>
  <h3>Parallel Performance</h3>
  <h3>Distributed Systems</h3>
  <h3>Cloud Computing</h3>
  <h3>Formal Models and Semantics</h3>
  <h2>Programmign Languages (PL)</h2>
  <h3>Object-Oriented Programming</h3>
  <h3>Functional Programming</h3>
  <h3>Event-Driven and Reactive Programming</h3>
  <h3>Basic Type Systems</h3>
  A type as a set of values together with a set of operations
  o Primitive types (e.g., numbers, Booleans)
  o Compound types built from other types (e.g., records, unions, arrays, lists, functions, references)
  • Association of types to variables, arguments, results, and fields
  • Type safety and errors caused by using values inconsistently given their intended types
  • Goals and limitations of static typing
  o Eliminating some classes of errors without running the program
  o Undecidability means static analysis must conservatively approximate program behavior
  <h3>Program Representation</h3>
  Programs that take (other) programs as input such as interpreters, compilers, type-checkers, documentation
  generators
  • Abstract syntax trees; contrast with concrete syntax
  • Data structures to represent code for execution, translation, or transmission
  <h3>Language Translation and Execution</h3>
  <h3>Syntax Analysis</h3>
  <h3>Compiler Semantic Analysis</h3>
  <h3>Code Generation</h3>
  <h3>Runtime Systems</h3>
  <h3>Static Analysis</h3>
  <h3>Advanced Programming Constructs</h3>
  <h3>Concurrency and Parallelism</h3>
  <h3>Type Systems</h3>
  <h3>Formal Semantics</h3>
  <h3>Language Pragmatics</h3>
  <h3>Logic Programming</h3>
  <h2>Software Development Fundamentals (SDF)</h2>
  <h3>Algorithms and Design</h3>
  <h3>Fundamental Programming Concepts</h3>
  Basic syntax and semantics of a higher-level language
  • Variables and primitive data types (e.g., numbers, characters, Booleans)
  • Expressions and assignments
  • Simple I/O including file I/O
  • Conditional and iterative control structures
  • Functions and parameter passing
  • The concept of recursion
  <h3>Fundamental Data Structures</h3>
  Arrays
  • Records/structs (heterogeneous aggregates)
  • Strings and string processing
  • Abstract data types and their implementation
  o Stacks
  o Queues
  o Priority queues
  o Sets
  o Maps
  • References and aliasing
  • Linked lists
  • Strategies for choosing the appropriate data structure
  <h3>Development Methods</h3>
  <h2>Software Engineering (SE)</h2>
  <h3>Software Processes</h3>
  <h3>Software Project Management</h3>
  <h3>Tools and Environments</h3>
  Software configuration management and version control
  • Release management
  • Requirements analysis and design modeling tools
  • Testing tools including static and dynamic analysis tools
  • Programming environments that automate parts of program construction processes (e.g., automated builds)
  o Continuous integration
  • Tool integration concepts and mechanisms
  <h3>Requirements Engineering</h3>
  <h3>Software Design</h3>
  System design principles: levels of abstraction (architectural design and detailed design), separation of
  concerns, information hiding, coupling and cohesion, re-use of standard structures
  • Design Paradigms such as structured design (top-down functional decomposition), object-oriented analysis
  and design, event driven design, component-level design, data-structured centered, aspect oriented,
  function oriented, service oriented
  • Structural and behavioral models of software designs
  • Design patterns
  <h3>Software Construction</h3>
  <h3>Software Verification and Validation</h3>
  <h3>Software Evolution</h3>
  <h3>Software Reliability</h3>
  <h3>Formal Methods</h3>
  <h2>Systems Fundamentals (SF)</h2>
  <h3>Computational Paradigms</h3>
  Basic building blocks and components of a computer (gates, flip-flops, registers, interconnections;
  Datapath + Control + Memory)
  • Hardware as a computational paradigm: Fundamental logic building blocks; Logic expressions,
  minimization, sum of product forms
  • Application-level sequential processing: single thread
  • Simple application-level parallel processing: request level (web services/client-server/distributed), single
  thread per server, multiple threads with multiple servers
  • Basic concept of pipelining, overlapped processing stages
  • Basic concept of scaling: going faster vs. handling larger problems
  <h3>Cross-Layer Communications</h3>
  <h3>State and State Machines</h3>
  <h3>Parallelism</h3>
  Sequential vs. parallel processing
  • Parallel programming vs. concurrent programming
  • Request parallelism vs. Task parallelism
  • Client-Server/Web Services, Thread (Fork-Join), Pipelining
  • Multicore architectures and hardware support for synchronization
  <h3>Evaluation</h3>
  <h3>Resource Allocation and Scheduling</h3>
  Kinds of resources (e.g., processor share, memory, disk, net bandwidth)
  • Kinds of scheduling (e.g., first-come, priority)
  • Advantages of fair scheduling, preemptive scheduling
  <h3>Proximity</h3>
  Speed of light and computers (one foot per nanosecond vs. one GHz clocks)
  • Latencies in computer systems: memory vs. disk latencies vs. across the network memory
  • Caches and the effects of spatial and temporal locality on performance in processors and systems
  • Caches and cache coherency in databases, operating systems, distributed systems, and computer
  architecture
  • Introduction into the processor memory hierarchy and the formula for average memory access time
  <h3>Virtualization and Isolation</h3>
  <h3>Reliability through Reduncancy</h3>
  <h3>Quantitative Evaluation</h3>
  <h2>Social Issues and Professional Practice (SP)</h2>
  <h3>Social Context</h3>
  Social implications of computing in a networked world (cross-reference HCI/Foundations/social models;
  IAS/Fundamental Concepts/social issues)
  • Impact of social media on individualism, collectivism and culture
  Growth and control of the Internet (cross-reference NC/Introduction/organization of the Internet)
  • Often referred to as the digital divide, differences in access to digital technology resources and its resulting
  ramifications for gender, class, ethnicity, geography, and/or underdeveloped countries.
  • Accessibility issues, including legal requirements
  • Context-aware computing (cross-reference HCI/Design for non-mouse interfaces/ ubiquitous and contextaware)
  <h3>Analytical Tools</h3>
  <h3>Professional Ethics</h3>
  <h3>Intellectual Property</h3>
  Philosophical foundations of intellectual property
  • Intellectual property rights (cross-reference IM/Information Storage and Retrieval/intellectual property and
  protection)
  • Intangible digital intellectual property (IDIP)
  • Legal foundations for intellectual property protection
  • Digital rights management
  • Copyrights, patents, trade secrets, trademarks
  • Plagiarism
  <h3>Privacy and Civil Liberties</h3>
  <h3>Professional Communication</h3>
  <h3>Sustainability</h3>
  <h3>History</h3>
  <h3>Economics of Computing</h3>
  <h3>Security Policies, Laws and Computer Crimes</h3>


  <h4>Principal Component Analysis</h4>
  <p>PCA is a dimensionality-reduction method used to reduce the dimensionality of large data sets, by transforming
    a
    large set of variables into a smaller one that still contains most of the information in the large set. The goal
    is
    to keep as much accuracy as possible while allowing for simplicity.</p>
  <p>The first step of PCA is standardization, which standardizes the range of continuous initial variables so that
    each
    one contributes equally to the analysis. If this is not performed, differences in the larger ranges will
    dominate
    over those with small ranges. This can be done mathematically by finding the z-score:</p>
  $$z=\frac{\text{value}-\text{mean}}{\text{standard deviation}}$$
  <p>The next step is covariance matrix computation. This aims to understand how the variables of the input data set
    are
    varying from the mean with respect to each other, to see if there is any relationship between them. The
    covariance
    matrix is a \(p\times p\) symmetric matrix (where p is the number of dimensions) that has as entries the
    covariances
    associated with all possible pairs of the initial variables. For example, a data set with 3 dimensions (say x,
    y,
    and z) would have a covariance matrix in this form:</p>
  $$ \left[
  \begin{array}{c}
  Cov(x,x)&Cov(x,y)&Cov(x,z)\\
  Cov(y,x)&Cov(y,y)&Cov(y,z)\\
  Cov(z,x)&Cov(z,y)&Cov(z,z)
  \end{array}
  \right] $$
  <p>Since the covariance of a variable with itself is its variance, the mani diagonal (top left to bottom right) is
    just the variances of each initial variable. And since the covariance is commutative (Cov(a,b,)=Cov(b,a)), the
    entries of the covariance matrix are symmetric with respect to the main diagonal.</p>
  <p>The next step is to compute the eigenvectors and eigenvalues of the covariance matrix to identify the principal
    components. Principal components are new variables that are constructed as linear combinations or mixtures of
    initial variables, but done in a way such that most of the information is compressed into the first components.
    So,
    10-dimensional data still gives you 10 principal components, but tries to put the maximum possible information
    into
    the first component, then the maximum remaining information in the second, and so on. Thus, you can discard
    components with low information and consider remaining components as your new variables. Geometrically speaking,
    principal components represent the directions of the data that explain a maximal amount of variance. Simply put,
    think of principal components as new axes that provide the best angle to see and evaluate the data, so that
    differences between observations are better visible. They are lines that maximize the variance (average of
    squared
    distances from the projected points to the origin).</p>
  <img src="{{url_for('static',filename='img/computer_science/PCA.gif')}}" style="width: 70%" alt="Builtin.com">
  <p>Now let's go back to eigenvectors and eigenvalues. Every eigenvector has an eigenvalue, and their number is
    equal
    to the number of dimensions of the data. For example, for a 3-dimensional data set, there are 3 variables and
    thus 3
    eigenvectors with 3 corresponding eigenvalues. The eigenvectors of the Covariance matrix are the directions of
    the
    axes where there is the most variance and that we call Principal Components. And eigenvalues are simply the
    coefficients attached to eigenvactors, which give the amount of variance carried in each Principal Component.
  </p>
  <p>Next, we create the feature vector. After we have ranked the principal components in order of significance, we
    choose which components we wish to discard, and form the remaining ones a matrix of vectors that we call the
    feature
    vector. This makes it the first step in dimensionality reduction, because we have removed principal components.
  </p>
  <p>Finally, we recast the data along the principal components axes. We use the feature vector to reorient the data
    from the original axes to the one represented by the principal components. This can be done by multiplying the
    transpose of the original data set by the transpose of the feature vector.</p>
  <h4>k-means clustering</h4>
  <p>k-means clustering is a method of vector quantization, originally from signal processing, that aims to
    partitian n
    observations into k clusters in whcih each observation belongs to the cluster with the nearest mean.</p>
  <h4>Uniform Manifold Approximation and Projection for Dimension Reduction</h4>
  <p>UMAP (Uniform Manifold Approximation and Projection) is a novel manifold learning technique for dimension
    reduction. UMAP is constructed from a theoretical framework based in Riemannian geometry and algebraic topology.
    The
    result is a practical scalable algorithm that applies to real world data. The UMAP algorithm is competitive with
    t-SNE for visualization quality, and arguably preserves more of the global structure with superior run time
    performance. Furthermore, UMAP has no computational restrictions on embedding dimension, making it viable as a
    general purpose dimension reduction technique for machine learning.</p>

  <h3>MongoDB-Express-Angular-NodeJS (MEAN) Stack</h3>
  <h4>Angular</h4>
  <p>Angular is a client-side (browser) framework which allows you to build Single-Page-Applications (SPA). It
    creates
    "mobile app"-like websites because there is no refreshing of the page.</p>
  <h4>NodeJS</h4>
  <p>NodeJS is a server-side library. It listens to requests and sends responses.</p>
  <h4>Express</h4>
  <p>Express is a Node framework which simplifies writing server-side code and logic.</p>
  <h4>mongoDB</h4>
  <p>mongoDB is a noSQL database which stores "documents" in collections" instead of "records" in "tables" as in
    SQL. It
    stores application data (users, products, etc.). It is more flexible in terms of structure compared to SQL.</p>
  <p>First you need to download and install NodeJS. Then install the Angular CLI. Then create a new Angular project
    (ng
    new). 'ng serve' will serve the project.</p>
  <p>Each component needs logic (ts file) and template (html file).</p>
</div>
{% endblock %}